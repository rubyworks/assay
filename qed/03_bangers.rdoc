= Banger Extensions

  require 'assay/bangers'

  class ::Object
    include ::Assay::Extensions
  end

== EqualityAssay

  1.equal!(1)

  expect ::EqualityAssay do
    1.equal!(2)
  end

    1.not_equal!(2)

== TrueAssay

  true.true!

  expect ::TrueAssay do
    false.true!
  end

  false.not_true!

== FalseAssay

  false.false!

  expect ::FalseAssay do
    true.false!
  end

  true.not_false!

== NilAssay

  nil.nil!

  expect ::NilAssay do
    true.nil!
  end

  true.not_nil!

== WithinAssay

  1.within!(2, 1.5)

  expect ::WithinAssay do
    1.within!(2, 0.5)
  end

  1.not_within!(2, 0.5)

== MatchAssay

  "abc".match!(/a/)

  expect ::MatchAssay do
    "abc".match!(/x/)
  end

  "abc".not_match!(/g/)

== SameAssay

  1.eql!(1)

  expect ::SameAssay do
    1.eql!(1.0)
  end

  1.not_eql!(1.0)

== IdentityAssay

  :a.equal!(:a)

  expect ::IdentityAssay do
    :a.equal!('a')
  end

  :a.not_equal!('a')

What it really should be, of course, is identical.

  :a.identical!(:a)

  expect ::IdentityAssay do
    "a".identical!("a")
  end

  :a.not_identical!('a')

== InstanceAssay

  1.instance_of!(Fixnum)

  expect ::InstanceAssay do
    1.instance_of!(String)
  end

  1.not_instance_of!(String)

== KindAssay

  1.kind_of!(Integer)

  expect ::KindAssay do
    1.kind_of!(String)
  end

  1.not_kind_of!(String)

== RaiseAssay

  procedure = lambda{ raise ::ArgumentError }

  procedure.raise!(::ArgumentError)

  expect ::RaiseAssay do
    procedure.raise!(::TypeError)
  end

  procedure.not_raise!(::TypeError)

== ResponseAssay

  "string".respond_to!(:upcase)

  expect ::ResponseAssay do
    "string".respond_to!(:not_a_method)
  end

  "string".not_respond_to!(:not_a_method)

== ExecutionAssay

  5.satisfy!{ |x| x > 3 }

  expect ::ExecutionAssay do
    5.satisfy!{ |x| x < 3 }
  end

  5.not_satisfy!{ |x| x < 3 }

== ThrowAssay

  procedure = lambda{ throw :foo }

  procedure.throw!(:foo)

  expect ::ThrowAssay do
    procedure.throw!(:bar)
  end

  procedure.not_throw!(:bar)

